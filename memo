* -f quiet するとよい
* yaml重複チェックオフ
* キャッシュが10000とかあると遅い, File.file?が10000回呼ばれて遅い(1回0.07msかかる)
  * 10000あっても大丈夫なようにするプルリクチャンス
* 以下のように、１個フリーズすると早い

before

-------

  56.4ms  5562 |  614          pattern.scan(TOKEN).reject { |token| token =~ /\A#{SEPARATORS}\Z/ }
               |  615          # pattern.scan(TOKEN).reject { |token| token =~ XXXX }

after
-------

               |  614          # pattern.scan(TOKEN).reject { |token| token =~ /\A#{SEPARATORS}\Z/ }
  24.8ms  5562 |  615          pattern.scan(TOKEN).reject { |token| token =~ XXXX }




* 以下のように cop.rbの一部メソッドをメモ化(110ms)

before

.....
               |  62
               |  63        def self.cop_name
  89.3ms 14348 |  64          badge.to_s
               |  65        end
               |  66
               |  67        def self.department
  10.2ms  7174 |  68          badge.department
               |  69        end
               |  70
              .......
               |  78          return false unless given_names
               |  79
 128.5ms 14348 |  80          given_names.include?(cop_name) ||
  49.6ms 21522 |  81            given_names.include?(department.to_s)
               |  82        end
               |  83


after
              .......
               |  70
               |  71        def self.department_name
   1.2ms   844 |  72          @department_name ||= department.to_s
               |  73        end
               |  74
              .......
               |  82          return false unless given_names
               |  83
  20.6ms 14348 |  84          given_names.include?(cop_name) ||
  21.7ms 14348 |  85            given_names.include?(department_name)
               |  86        end
               |  87

*Array#&を使う


```
--- a/lib/rubocop/cop/registry.rb
+++ b/lib/rubocop/cop/registry.rb
@@ -56,7 +56,9 @@ module RuboCop
       end

       def contains_cop_matching?(names)
-        cops.any? { |cop| cop.match?(names) }
+        return false unless names
+
+        !(cops & names).empty?
       end
```

before

lib/rubocop/cop/registry.rb
               |  59          return false unless names
               |  60
 106.9ms  7208 |  61          cops.any? { |cop| cop.match?(names) }
               |  62        end
               |  63

              .......
               |  484
               |  485      def warn_about_unrecognized_cops(invalid_cop_names)
 108.6ms     2 |  486        invalid_cop_names.each do |name|
               |  487          # There could be a custom cop with this name. If so, don't warn
 106.4ms    17 |  488          next if Cop::Cop.registry.contains_cop_matching?([name])
               |  489
               |  490          # Special case for inherit_mode, which is a directive that we keep in
              .......

after


lib/rubocop/cop/registry.rb
               |  59          return false unless names
               |  60
  22.4ms  7208 |  61          !(cops & names).empty?
               |  62        end
               |  63

              .......
               |  484
               |  485      def warn_about_unrecognized_cops(invalid_cop_names)
  25.0ms     2 |  486        invalid_cop_names.each do |name|
               |  487          # There could be a custom cop with this name. If so, don't warn
  23.2ms    17 |  488          next if Cop::Cop.registry.contains_cop_matching?([name])
               |  489
               |  490          # Special case for inherit_mode, which is a directive that we keep in
              .......

* 引数が1個の単純なときスキップしたい

before

lib/rubocop/runner.rb
               |  36        #  target_files = [File.absolute_path(paths.first)]
               |  37        # else
  82.2ms     1 |  38        target_files = find_target_files(paths)
               |  39        # end
               |  40        # warn(Time.now - t)


* きづいたこと

これのputs、重複してる

# frozen_string_literal: true

module RuboCop
  module Performance
    # Because RuboCop doesn't yet support plugins, we have to monkey patch in a
    # bit of our configuration.
    module Inject
      def self.defaults!
        path = CONFIG_DEFAULT.to_s
        hash = ConfigLoader.send(:load_yaml_configuration, path)
        config = Config.new(hash, path)
        puts "configuration from #{path}" if ConfigLoader.debug?
        config = ConfigLoader.merge_with_default(config, path)
        ConfigLoader.instance_variable_set(:@default_configuration, config)
      end
    end
  end
end
